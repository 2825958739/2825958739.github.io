{"meta":{"title":"无定文集","subtitle":"㲽木的博客","description":"本科 | 安徽工程大学 | 物联网工程 | 前端开发","author":"ChenLiang","url":"https://2825958739.github.io","root":"/"},"pages":[{"title":"","date":"2022-03-24T05:01:08.237Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://2825958739.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"404.html","permalink":"https://2825958739.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2022-03-24T05:01:08.246Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://2825958739.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/index.html","permalink":"https://2825958739.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"archives/index.html","permalink":"https://2825958739.github.io/archives/index.html","excerpt":"","text":""},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"about/index.html","permalink":"https://2825958739.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"categories/index.html","permalink":"https://2825958739.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"friends/index.html","permalink":"https://2825958739.github.io/friends/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2022-03-24T12:30:09.400Z","comments":true,"path":"contact/index.html","permalink":"https://2825958739.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 㲽木の友链信息 博客名称: 㲽木の博客 博客网址: Luckey (2825958739.github.io) 博客头像: https://s1.ax1x.com/2022/03/24/qJQKjP.jpg 博客介绍: The harder you work, the luckier you will be"},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"census/index.html","permalink":"https://2825958739.github.io/census/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"resource/index.html","permalink":"https://2825958739.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"tags/index.html","permalink":"https://2825958739.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-03-24T05:01:08.019Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/index.html","permalink":"https://2825958739.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/movies/index.html","permalink":"https://2825958739.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/music/index.html","permalink":"https://2825958739.github.io/List/music/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/tools/index.html","permalink":"https://2825958739.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-03-24T05:01:08.020Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://2825958739.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-03-24T05:01:08.021Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://2825958739.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2022-03-24T05:01:08.020Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://2825958739.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-03-24T05:01:08.023Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://2825958739.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-03-24T05:01:08.022Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://2825958739.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-03-24T05:01:08.026Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://2825958739.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-03-24T05:01:08.027Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://2825958739.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-03-24T05:01:08.028Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://2825958739.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2022-03-24T05:01:08.029Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://2825958739.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2022-03-24T05:01:08.028Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://2825958739.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2022-03-24T05:01:08.029Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://2825958739.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-03-24T05:01:08.030Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://2825958739.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"Movie-Tree","slug":"Movie-Tree","date":"2023-05-07T08:53:20.000Z","updated":"2023-05-07T08:53:20.506Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://2825958739.github.io/posts/undefined.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Reading_Tree","slug":"Reading-Tree","date":"2023-05-04T13:23:39.000Z","updated":"2023-05-07T09:08:22.953Z","comments":true,"path":"posts/386b424e.html","link":"","permalink":"https://2825958739.github.io/posts/386b424e.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"TCP/IP 面试题","slug":"tcp-test","date":"2023-03-20T13:41:36.000Z","updated":"2023-03-20T13:51:11.695Z","comments":true,"path":"posts/b67522a1.html","link":"","permalink":"https://2825958739.github.io/posts/b67522a1.html","excerpt":"","text":"三次握手与四次挥手？三次握手 第一次握手：建立连接时，客户端发送SYN包到服务端，其中包含客户端的初始序号seq=x,并进入SYN_SENT(同步已发送)状态，等待服务器确认。（其中SYN=1，ACK=0，表示这是一个TCP连接请求数据报文；序号seq=x，表明数据传输数据时第一个数据字节的序号是X）. 第二次握手：服务器收到请求后，必须确认客户的数据包。同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN_RECV（同步以收到）状态。（其中确认报文段中，标识位SYN=1,ACK=1，表示这是一个TCP连接响应数据报文，并包含服务器的初始序号seq(服务器)=y,以及服务器对客户端初始序号的确认号ack(服务器)=seq（客户端）+1=x+1）. 第三次握手：客户端收到服务器的SYN+ACK 包，向服务器发送一个序列号(seq=x+1)，确认号为ack=y+1,此包发送完毕，客户端和服务器进入ESTAB_LISHED（TCP连接成功)状态，完成三次握手。 为啥三次握手：假设客户端请求建立连接，发给服务器SYN包等待服务器确认，服务器收到确认后，如果是两次握手，假设服务器给客户端在第二次握手时发送数据，数据从服务器发出，服务器任务连接已经建立，但在发送数据的过程中数据丢失，客户端认为连接没有建立，会进行重传。假设每一次发送的数据一直在丢失，客户端一直SYN，服务器就会产生多个无效连接，占用资源，这个时候服务器可能会挂掉。这就是SYN的洪水攻击 第三次握手是为了防止：如果客户端迟迟没有收到服务器返回确认报文，这时会放弃连接，重新启动一条连接请求，但问题是：服务器不知道客户端没有收到，所以他会收到两个连接，浪费连接开销。如果每次都是这样，就会浪费多个连接开销。 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。因此，需要三次握手才能确认双方的接收与发送能力是否正常。 为什么需要经过2MSL(报文段在网络中最大生存时间)才能返回到CLOSE状态？ 是为了给最后一次发送的ACK报文成功到达服务端预留时间，因为如果因为网络阻塞最后一次ACK未能及时到达服务端，服务端会以为客户端为收到上一次发送的FIN报文，则服务端会重新发送FIN报文，而这是客户端已经断开连接了，这时就是产生错乱的问题。 四次挥手 step1：第一次挥手首先，客户端发送一个FIN，用来关闭客户端到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u。 step2：第二次挥手服务器收到这个FIN，它发送一个ACK，确认ack为收到的序号加一。 step3：第三次挥手关闭服务器到客户端的连接，发送一个FIN给客户端。 step4：第四次挥手客户端收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加一。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 客户端发送FIN后，进入终止等待状态，服务器收到客户端连接释放报文段后，就立即给客户端发送确认，服务器就进入CLOSE_WAIT状态，此时TCP服务器进程就通知高层应用进程，因而从客户端到服务器的连接就释放了。此时是“半关闭状态”，即客户端不可以发送给服务器，服务器可以发送给客户端。此时，如果服务器没有数据报发送给客户端，其应用程序就通知TCP释放连接，然后发送给客户端连接释放数据报，并等待确认。客户端发送确认后，进入TIME_WAIT状态，但是此时TCP连接还没有释放，然后经过等待计时器设置的2MSL后，才进入到CLOSE状态。 DNS域名解析过程？ 步骤一：当在浏览器中输入域名按下回车键后，浏览器会检查缓存中有没有这个域名对应的解析过的IP地址。如果缓存有，解析结束。浏览器缓存域名在大小和时间上都是有限制的。缓存时间可由TTL属性来设置缓存时间太长太短都不好，太长，会导致IP解析有变化，会导致域名不能正常解析，部分用户无法访问网站。缓存时间太短，用户每次都需要重新解析一次域名。 步骤二：如果用户的浏览器中缓存没有，浏览器会查找操作系统中是否有这个域名对应的DNS解析结果。其实操作系统中也会有一个域名解析的过程，在windows中可以通过c:\\windows\\system32\\drivers\\etc\\hosts文件来设置，你可以将任何域名解析到任何能够访问的IP地址。（黑客劫持域名）步骤一和步骤二都是由本机完成的。 步骤三：当机无法完成域名解析，就会真正请求域名服务器来解析这个域名了。我们怎样知道域名服务器？网络配置中都会有“DNS服务器地址”操作系统会把这个域名发送到设置中的LDNS，也就是本地的域名服务器。DNS通常都会提供给你本地互联网接入的一个DNS服务器。比如你在学校，那么这个DNS服务器一定在你们学校。WIndows中可由ipconfig查询这个地址。 步骤四：如果LDNS仍然没有解析到，就直接到Root Service域名解析器请求解析 步骤五：根域名服务器返回给本地域名服务器一个所查询余的主域名服务器（gTLDServer）地址。gTLD是国际顶级域名服务器，如：.com/.cn/.org等，全球只有13台左右。 步骤六：本地域名服务器（Local DNS Server）再向上一步返回的gTLD服务器发送请求 步骤七：接收请求的gTLD服务器查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是你注册的域名服务器（如你的域名供应商） 步骤八：Name Server域名服务器会查询存储的域名和IP的映射关系表，正常情况下都根据域名得到目标IP记录，连同一个TTL值返回给DNS Server域名服务器 步骤九：返回该域名对应的IP和TTL值，Local DNS Server会缓存这个域名和IP的对应关系，缓存的时间有TTL值控制。 步骤十：把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。 关于DNS解析的TTL参数： 我们在配置DNS解析的时候，有一个参数常常容易忽略，就是DNS解析的TTL参数，Time To Live。TTL这个参数告诉本地DNS服务器，域名缓存的最长时间。用阿里云解析来举例，阿里云解析默认的TTL是10分钟，10分钟的含义是，本地DNS服务器对于域名的缓存时间是10分钟，10分钟之后，本地DNS服务器就会删除这条记录，删除之后，如果有用户访问这个域名，就要重复一遍上述复杂的流程。 什么是TCP/IP协议？ 指能够在多个不同网络间实现信息传输的协议簇。TCP/IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇。 传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 TCP和UDP的区别？ TCP UDP 可靠性 可靠 不可靠 连接性 面向连接 无连接 报文 面向字节流 面向数据报文 效率 可靠 不可靠 双工性 全双工 一对一、一对多、多对一、多对多 流量控制 滑动窗口 无 传输速度 慢 快 应用场景 对效率要求低，对准确性要求高或者要求有连接的场景 对效率要求高，对准确性要求低 TCP和UDP各自的特点和应用场景 TCP应用场景：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录，视频。 UDP应用场景:qq聊天、直播、网络语音电话、广播通信（广播、多播）。 为什么tcp的传输速率会比udp慢 因为UDP没有流控，没有握手，没有成功确认，一个数据包发过去就不管，从这个角度上说TCP是开销大一点 介绍一下tcp的滑动窗口 窗口机制实际上是一种流量控制的手段，它是一段缓冲区，在信息传递的过程中用户端和服务器端各自分配一块缓冲区来存储接收的数据，此时通讯的时候我们需要告诉对方我们的缓冲区的大小，不然对方发送数据的时候不知道你最大能接收的信息到底多大。 如果发送多组数据，则接收方的确认信息包含了自己剩下的缓冲区大小。所以我们把剩下的缓冲区大小叫做窗口。 tcp拥塞窗口的变化规律 只要网络中没有出现拥塞，cwnd 就会增大；但网络中出现了拥塞，cwnd 就减少 为什么要有拥塞控制呀，不是有流量控制了吗？ 一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。 在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大…. 所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。 于是，就有了拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络。 为了在「发送方」调节所要发送数据的量，定义了一个叫做「拥塞窗口」的概念。 什么是拥塞窗口？和发送窗口有什么关系呢？ 拥塞窗口 cwnd是发送方维护的一个 的状态变量，它会根据网络的拥塞程度动态变化的。 我们在前面提到过发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。 拥塞窗口 cwnd 变化的规则：只要网络中没有出现拥塞，cwnd 就会增大；但网络中出现了拥塞，cwnd 就减少； 怎么知道当前网络是否出现了拥塞呢？ 只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了用拥塞。 HTTP协议 HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。 主要特点： 1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 5、支持B/S及C/S模式。 URI和URL的区别URI 是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。 Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的URI一般由三部组成：①访问资源的命名机制②存放资源的主机名③资源自身的名称，由路径表示，着重强调于资源。 URL 是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。 URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：①协议(或称为服务方式)②存有该资源的主机IP地址(有时也包括端口号)③主机资源的具体地址。如目录和文件名等 HTTP之请求消息Request客户端发送一个HTTP请求到服务器的请求消息包括以下格式： 请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。 第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本. GET说明请求类型为GET,GET后面是要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。 第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息 从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等 第三部分：空行，请求头部后面的空行是必须的 即使第四部分的请求数据为空，也必须有空行。 第四部分：请求数据也叫主体，可以添加任意的其他数据。 HTTP之响应消息Response一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。 HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。 第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok） 第二部分：消息报头，用来说明客户端要使用的一些附加信息 第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8 第三部分：空行，消息报头后面的空行是必须的 第四部分：响应正文，服务器返回给客户端的文本信息。 HTTP之状态码 状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别: 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 200：请求被正常处理204：请求被受理但没有资源可以返回 3xx：重定向–要完成请求必须进行更进一步的操作 301：永久性重定向302：临时重定向 4xx：客户端错误–请求有语法错误或请求无法实现 400：请求报文语法有误，服务器无法识别401：请求需要认证403：请求的对应资源禁止被访问404：服务器无法找到对应资源 5xx：服务器端错误–服务器未能实现合法的请求 500：服务器内部错误503：服务器正忙 HTTP 请求/响应的步骤 1、客户端连接到Web服务器 一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.oakcms.cn。 2、发送HTTP请求 通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。 3、服务器接受请求并返回HTTP响应 Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。 4、释放连接TCP连接 若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; 5、客户端浏览器解析HTML内容 客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。 例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程： 1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址; 2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接; 3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器; 4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器; 5、释放 TCP连接; 6、浏览器将该 html 文本并显示内容。 常用的HTTP方法有哪些？ GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器。 POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。 PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。 HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。 DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。 OPTIONS：查询相应URI支持的HTTP方法。 GET方法与POST方法的区别 区别一：get重点在从服务器上获取资源，post重点在向服务器发送数据； 区别二：get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用”?”连接，多个请求数据间用”&amp;”连接，如http://127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的；post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的； 区别三：Get传输的数据量小，因为受URL长度限制，但效率较高；Post可以传输大量数据，所以上传文件时只能用Post方式； 区别四：get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等；post较get安全性较高； 区别五：get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。post支持标准字符集，可以正确传递中文字符。 常见HTTP首部字段a、通用首部字段（请求报文与响应报文都会使用的首部字段）Date：创建报文时间Connection：连接的管理Cache-Control：缓存的控制Transfer-Encoding：报文主体的传输编码方式b、请求首部字段（请求报文会使用的首部字段）Host：请求资源所在服务器Accept：可处理的媒体类型Accept-Charset：可接收的字符集Accept-Encoding：可接受的内容编码Accept-Language：可接受的自然语言c、响应首部字段（响应报文会使用的首部字段）Accept-Ranges：可接受的字节范围Location：令客户端重新定向到的URIServer：HTTP服务器的安装信息d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）Allow：资源可支持的HTTP方法Content-Type：实体主类的类型Content-Encoding：实体主体适用的编码方式Content-Language：实体主体的自然语言Content-Length：实体主体的的字节数Content-Range：实体主体的位置范围，一般用于发出部分请求时使用 HTTP的缺点与HTTPSa、通信使用明文不加密，内容可能被窃听b、不验证通信方身份，可能遭到伪装c、无法验证报文完整性，可能被篡改 HTTPS就是HTTP加上加密处理（一般是SSL安全通信线路）+认证+完整性保护","categories":[{"name":"面试题","slug":"面试题","permalink":"https://2825958739.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"tcp/ip网络协议","slug":"tcp-ip网络协议","permalink":"https://2825958739.github.io/tags/tcp-ip%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"HTTP","slug":"HTTP","permalink":"https://2825958739.github.io/tags/HTTP/"}],"author":"chenliang"},{"title":"管道智能检测系统","slug":"Pipeline-detection-system","date":"2023-03-15T15:55:53.000Z","updated":"2023-03-16T04:48:39.125Z","comments":true,"path":"posts/db8fdaea.html","link":"","permalink":"https://2825958739.github.io/posts/db8fdaea.html","excerpt":"","text":"项目背景DMA分区计量管理系统，通过摸排城区现有管网布局，进行合理分区规划，通过分区计量控制供水量，并进行分级管理。分区计量带来的好处就是能够实现对漏损处的精准定位，及时进行修复保障供水。通过物联网技术，配备远程水流量传感器和管网压力监测设备，实现分区分级精确计量，检漏定位50m范围之内，进而快速修复，缩短泄漏时间。DMA系统强大的数据采集、分析功能可以通过每天比对总、分表数据来分析推算这个小区区域管网可能的漏水量和漏水点范围，如果发现数据大幅波动，会追查相应分区计量表，定位漏损范围、查找原因，从而帮助巡检员由盲目检测、被动检测、“救火式”抢修实现精准检漏、主动检漏、“保养式”维护，从而达到有效降低管网漏损的目的。 第一章 作品概述1.1、水资源现状水资源一直以来都是我们赖以生存的重要资源，我国更是众所周知的水资源总数丰富，但人均水资源匮乏，这便使得水资源的合理利用一直以来便是我国的研究重点。 1.2、市场需求2015年4月国务院颁布“水十条”后，各地都在加紧进行改善水环境质量的行动。除了对水污染的治理，对城市供水系统的改善也成为越来越热的话题，智能水务这个新鲜事物也逐渐火了起来。中国的水务系统长年来管理水平较低，每年损失较大。有统计数据显示，全国自来水厂平均产销差率高达30%，在中西部缺水城市甚至超过45%，东北部分城市超过50%，城市水网中漏损水量的经济价值高达200亿元以上。国内600多个城市供水管网的平均漏损率超过15%，最高达50％以上。 其中产销差率，在国外它被称为“未计量水百分率”，指的是供水企业提供给城市输水配水系统的自来水总量与所有用户的用水量总量中收费部分的差值定义为产销差水，产销差水 = 免费供水量 + 物理漏水量 + 帐面漏水量。产销差率=[（供水量-售水量）/供水量]x100%。下图1-1展示了上海各自来水公司产销差率： 这些数据的背后隐藏着巨大的市场商机。而在在大数据时代，可以通过对数据的监测、采集、分析和辅助日常及应急决策，使水务资产能够更加高效、可靠运行，这就是DMA结合物联网技术监测管网漏损的基本模式。（即一种新型智慧水务模式） 1.3、项目前景分析以此项目为基础，依托项目前期铺设的传感网与M2M技术框架，在此基础上建设更多水务相关传感设备（如：压力计、水质监测仪器、浊度计、监控器等，由下图1-5所示）大大增加了该项目的使用范围，能够搭建一个十分完善的智慧水务平台，不仅仅是监测管网的漏损，更能够提供多元化服务，如管网内的各项水质指标监测，污水排放监测等等。 1.4、应用场景分析本项目搭建的基础水务平台可以应用对于降低管网漏损率有要求的城市，同时也可以应用于想提高生产收益，降低水管漏损率的企业。在项目基础上扩建感知层后，可以用于城市的智慧水务建设、农村智慧供水的规划、城市饮用水水源地水质监测与企业污水排放监测等 第二章 作品设计2.1、系统设计方案系统功能框架如图 1 所示。系统主要分为如下模块 ： ESP8266 模块为程序控制和 WiFi 无线通信主控模块， 主要功能包括控制传感模块进行环境信息的采集，并将采集 的信息通过 WiFi 模块经路由器传送到云平台； 传感模块主要包括水流量检测模块、水质检测模块，用于检测水流量和水质信息； 云平台模块主要用于检测数据的云存储和网页端显示； 手机 APP 主要用于远程监控，云平台通过 Internet 将用户信息和检测数据传送到手机APP。 2.2、底层硬件（1）ESP8266-01s开发板 ESP8266这个词可以理解为ESP8266EX芯片，以及依赖ESP8266EX芯片开发的系列模组的简称。esp8266 EX是乐鑫信息科技（上海）股份有限公司开发的一系列的wifi芯片ESP8266系列模组是深圳安信可（Ai-thinker）公司开发的一系列基于乐鑫ESP8266EX的超低功耗的UART-WiFi模块的模组，可以方便地进行二次开发，接入云端服务。 ESP8266是由乐鑫公司出品的一款物联网芯片，因为价格较低，性能稳定等收到很大的关注。它是一款比较通用的WiFi 芯片，其核心为一块Diamond Standard 106Micro控制器的高集成度芯片。该芯片是当时行业内集成度较高的WiFi MCU芯片，集成了32位MCU、WiFi射频、基带、MAC、TCP/IP于单颗 SoC 上，实现了板上占用空间最小化。同时ESP8266 也只有7个外围器件，大大降低了ESP8266的模组BOM成本，也正因为如此，该芯片迎合了智能家居市场的价格要求。另外，该芯片的 WLAN 拥有领先的电源控制算法，可在省电模式下工作，满足电池和电源设备苛刻的供电要求。 基本参数： 工作电压：DC3.0-3.6V（建议3.3V） SPI Flash：1MB 板载PCB天线增益:3DBi 模块优势： 1）价格低，基本只赚取很小的利润，希望此举能带动物联网更迅速的发展 2）体积最小做到11*10毫米左右，指甲盖大小。方便嵌入到任何产品 3）功能强大内部跑LWIP协议 4）支持三种模式：AP,STA,AP+STA 共存模式 实物图： （3）YF-S201水流量检测传感器模块 YF-S201水流量传感器是指通过对水流量的感应而输出脉冲信号或电流、电压等信号的水流量感应仪器，这种信号的输出和水流量成一定的线性比例，有相应的换算公式和比较曲线，因此可做水控方面的管理和流量计算，在热力方面配合换能器可测量一段时间介质能量的流失，如热能表。水流传感器主要和控制芯片、单片机，甚至PLC配合使用。水流传感器具有流量控制准确，可以循环设定动作流量，水流显示和流量累积计算的作用。如下图所示，主要由阀体、水流转子组件和霍尔传感器组成。当水通过水流转子组件时，带动磁性转子转动且霍尔传感器输出相应脉冲信号，可通过检测脉冲信号来判断水流量的多少。 流量：是指单位时间内流经封闭管道或明渠有效截面的流体量，又称瞬时流量。当流体量以体积表示时称为体积流量；当流体量以质量表示时称为质量流量。单位时间内流过某一段管道的流体的体积，称为该横截面的体积流量。简称为流量，用Q来表示。对在一定通道内流动的流体的流量进行测量统称为流量计量。流量测量的流体是多样化的，如测量对象有气体、液体、混合流体；流体的温度、压力、流量均有较大的差异，要求的测量准确度也各不相同。可分为浮标法、流速仪法、超声波法等，流速仪法测量精度最高。 （4）MT3608升压板 （1）模块介绍 TCOOP-M004-MT3608升压模块是一种恒定频率，电流模式升压转换器，用于小型，低功耗应用。 MT3608升压模块开关频率为1.2MHz，使用小体积的电容和电感。内部软启动导致小涌流并延长使用寿命。 MT3608升压模块在低负载下自动切换到脉冲调频模式，在超负载情况下自动保护，包括欠压锁定，限流保护和热过载保护。 (2)运行原理 (3)技术参数 输入电压 2-5V 输出电压 5V 输出电流 1.2A 效率 97% 保护 欠压锁定，限流保护，热过载保护 开关频率 1.2M Hz 工作温度 -40°C ~ +85°C 待机电流 200uA 2.3、网络传输协议MQTT是一个客户端服务端架构的发布/订阅模式的消息传输协议。它的设计思想是轻巧、开放、简单、规范，易于实现。这些特点使得它对很多场景来说都是很好的选择，特别是对于受限的环境如机器与机器的通信（M2M）以及物联网环境（IoT）。 MQTT服务端：MQTT服务端通常是一台服务器。它是MQTT信息传输的枢纽，负责将MQTT客户端发送来的信息传递给MQTT客户端。MQTT服务端还负责管理MQTT客户端。确保客户端之间的通讯顺畅，保证MQTT消息得以正确接收和准确投递。 MQTT客户端：MQTT客户端可以向服务端发布信息，也可以从服务端收取信息。我们把客户端发送信息的行为成为“发布”信息。而客户端要想从服务端收取信息，则首先要向服务端“订阅”信息。“订阅”信息这一操作很像我们在视频网站订阅某一部电视剧。当这部电视剧上新后，视频网站会向订阅了该剧的用户发送信息，告诉他们有新剧上线了。 MQTT主题：刚刚我们在讲解MQTT客户端订阅信息时，使用了用户在视频网站订阅电视剧这个例子。在MQTT通讯中，客户端所订阅的肯定不是一部部电视剧，而是一个个“主题”。MQTT服务端在管理MQTT信息通讯时，就是使用“主题”来控制的。 2.3、线路搭建 2.4、物联网应用平台开发EMQX 是一款「随处运行，无限连接，任意集成」云原生分布式物联网接入平台。EMQX 企业版提供一体化的分布式 MQTT 消息服务和强大的 IoT 规则引擎，为高可靠、高性能的物联网实时数据移动、处理和集成提供动力，助力企业快速构建关键业务的 IoT 平台与应用。 （1）安装 EMQX DashboardEMQX Dashboard（EMQX 管理控制台，以下简称 Dashboard) 是 EMQX 提供的一个后端 Web控制台，用户可通过 Web 控制台查看服务器节点和集群的运行状态、统计指标，客户端的在线情况和订阅关系等信息，并进行插件配置与停启，HTTP API 密钥管理，EMQX 集群的热配置管理和 MQTT 连接测试等操作。 （2）网页端显示 （3）手机APP端显示 第三章 技术分析3.1、硬件原理 图所示为系统硬件原理，本文采用 ESP8266-01s 模块 3.2、水流量传感器工作原理​ （1）水流量传感器主要由塑料阀体 、水流转子组件和霍尔传感器组成。水流量传感器是利用霍尔元件的霍尔效应来测量磁性物理量。 在霍尔元件的正极串入负载电阻， 同时5V通上 的直流电压并使电流方向与磁场方向正交。 当水通过涡轮开关壳推动磁性转子转动时， 产生不同磁极的旋场转，磁切割磁感应线，产生高低脉冲电平。由于霍尔元件的输出脉冲信号频率与磁性转子的转速成正比，转子的转又速 与水流量成正比，根据水流量的大小启动燃气热水器。其脉冲信号频率的经验公式见式(1)。 程序流程图如下： 原理图设计： 特性： （2）霍尔效应霍尔效应是电磁效应的一种，这一现象是美国物理学家霍尔（A.H.Hall，1855—1938）于1879年在研究金属的导电机制时发现的。当电流垂直于外磁场通过导体时，在导体的平行于磁场和电流方向的两个端面之间会出现电势差，这一现象就是霍尔效应。这个电势差也被称为霍尔电势差。霍尔效应应使用左手定则判断。在半导体上外加与电流方向垂直的磁场，会使得半导体中的电子与空穴受到不同方向的洛伦兹力而在不同方向上聚集，在聚集起来的电子与空穴之间会产生电场，此电场将会使后来的电子和空穴受到电场力的作用而平衡掉磁场对其产生的洛伦兹力，使得后来的电子和空穴能顺利通过不会偏移，此称为霍尔效应。 霍尔传感器工作原理： 第四章 创新性说明4.1、传统供水管网漏损的检测方法（1）被动检漏法 被动检测就是最原始的检测方法，就是等地下管网的漏水量已经冒出地面后才被发现的检测方法。此种方法需要的检漏人员少，资金费用低，但是总是后知后觉，对于管网的水量损失确是巨大的。 （2）主动检漏法 主动捡漏方法就是通过一起设备结合理论知识，有预见性的去检测管网的漏损情况。常见的主动检漏方法有：听音捡漏法、相关检漏法。听音检漏法主要是通过通过听音仪器寻找地下管道的漏损点，一般情况下声音最大的点就是漏损点。听音检漏法可分为阀栓听音法和地面听音法两种，阀栓听音用于漏损的预定位，地面听音主要用于漏损点的精确定位。 相关检漏法就是通过利用漏水噪声传到两端探测器的时间差来计算定位漏损点的位置。此法的要求就是探测器必须要与管道直接接触，在获得管道材质和管道长度的数据后能够分析出漏损点与探测器间的位置；缺点就是当管段中存在不止一处漏损点时，仪器无法得出正确的结果；而且探测器的位置间距不宜过大。最佳的检测条件就是，管道的直径 DN&lt;400mm，两个接触点距离小于 200m。 4.2、国外供水漏损控制研究进展及国内外差距目前，国外主要的的检漏方法就是主动检漏法，常用的有区域检漏法，通过监测记录器记录数据，通过两种不同的方法进行数据处理： 将平均日用水量与夜间最小流量做比较，如果二者的比值超过某一百分数（每个国家的规定不相同，美国一般为 50%）就认为可能存在发生漏损的可能性。 利用历史供水管网正常运行得到的数据，结合管网现状绘制具有参考价值的标准图形，利用标准图形为历史背景值，将需要检测的数据与其做比较，对比两者的线性变化是否存在巨大差异，以此为判断基准，从而确定是否存在漏损发生的可能性。 国外与国内还有较大的差距就是，国外的漏损控制研究工作发展比国内早很对年，具有更加先进的检漏技术以及更加智能的检测仪器，如地表雷达检漏法、复合法等科学方法；水传声相关检漏仪、地表雷达探测仪等智能仪器。在考虑方法与设备的基础上,国外对于漏损控制在就开始考虑成本问题，利用成本与控制效果做曲线分析，从而找到最佳的漏损控制方案。由于西方国家在研究漏损领域的技术和仪器设备领先我国好多年，而且在具有较大的基础建设经费投资的基础上，相比于西方国家的管网漏损率，我国的管网漏损率还有巨大的进步空间。 4.3、产品创新点由于管网漏损形态与主导因素各异，传统检漏仪大多都存在精度不高、余音干扰等问题，而先进探漏检漏设备又主要依赖进口，很难实现对供水管网进行深入、持续的漏水控制。当遇到以下情况时无法应用常规检漏设备进行检测： 管道埋设太深，漏水声能量被埋覆土吸收，无法监听漏水异常点； 漏口被水淹没，漏水声能量被水吸收—水包管，无法获取漏水点； 水压太低，导致漏口处产生的漏水声很微弱，无法获取漏水点； 漏口上方有下水管道隔音，漏水点定位准确率低； 管道接口处渗漏，几乎无漏水声，无法发现漏水异常； 地面上有建筑物或堆积物，无听漏条件，无法获取暗漏点 而对于我们研究的技术而言。DMA分区计量管理系统，通过摸排城区现有管网布局，进行合理分区规划，通过分区计量控制供水量，并进行分级管理。分区计量带来的好处就是能够实现对漏损处的精准定位，及时进行修复保障供水。通过物联网技术，配备远程水流量传感器和管网压力监测设备，实现分区分级精确计量，检漏定位50m范围之内，进而快速修复，缩短泄漏时间。DMA系统强大的数据采集、分析功能可以通过每天比对总、分表数据来分析推算这个小区区域管网可能的漏水量和漏水点范围，如果发现数据大幅波动，会追查相应分区计量表，定位漏损范围、查找原因，从而帮助巡检员由盲目检测、被动检测、“救火式”抢修实现精准检漏、主动检漏、“保养式”维护，从而达到有效降低管网漏损的目的。DMA技术分区如下图：","categories":[{"name":"物联网应用集","slug":"物联网应用集","permalink":"https://2825958739.github.io/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E9%9B%86/"}],"tags":[{"name":"物联网系统","slug":"物联网系统","permalink":"https://2825958739.github.io/tags/%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F/"},{"name":"管道检测","slug":"管道检测","permalink":"https://2825958739.github.io/tags/%E7%AE%A1%E9%81%93%E6%A3%80%E6%B5%8B/"},{"name":"Esp8266-01s","slug":"Esp8266-01s","permalink":"https://2825958739.github.io/tags/Esp8266-01s/"},{"name":"水流量传感器","slug":"水流量传感器","permalink":"https://2825958739.github.io/tags/%E6%B0%B4%E6%B5%81%E9%87%8F%E4%BC%A0%E6%84%9F%E5%99%A8/"}],"author":"chenliang"},{"title":"数据库笔记","slug":"mysql-studynotes","date":"2023-03-09T13:38:24.000Z","updated":"2023-03-09T05:44:43.345Z","comments":true,"path":"posts/aaba1da3.html","link":"","permalink":"https://2825958739.github.io/posts/aaba1da3.html","excerpt":"","text":"基础篇通用语法及分类 DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段） DML: 数据操作语言，用来对数据库表中的数据进行增删改 DQL: 数据查询语言，用来查询数据库中表的记录 DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限 DDL（数据定义语言）数据定义语言 数据库操作查询所有数据库：SHOW DATABASES;查询当前数据库：SELECT DATABASE();创建数据库：CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];删除数据库：DROP DATABASE [ IF EXISTS ] 数据库名;使用数据库：USE 数据库名; 注意事项 UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集 表操作查询当前数据库所有表：SHOW TABLES;查询表结构：DESC 表名;查询指定表的建表语句：SHOW CREATE TABLE 表名; 创建表： CREATE TABLE 表名( 字段1 字段1类型 [COMMENT 字段1注释], 字段2 字段2类型 [COMMENT 字段2注释], 字段3 字段3类型 [COMMENT 字段3注释], ... 字段n 字段n类型 [COMMENT 字段n注释] )[ COMMENT 表注释 ]; 最后一个字段后面没有逗号 添加字段：ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];例：ALTER TABLE emp ADD nickname varchar(20) COMMENT '昵称'; 修改数据类型：ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);修改字段名和字段类型：ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];例：将emp表的nickname字段修改为username，类型为varchar(30)ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT '昵称'; 删除字段：ALTER TABLE 表名 DROP 字段名; 修改表名：ALTER TABLE 表名 RENAME TO 新表名 删除表：DROP TABLE [IF EXISTS] 表名;删除表，并重新创建该表：TRUNCATE TABLE 表名; DML（数据操作语言）添加数据指定字段：INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);全部字段：INSERT INTO 表名 VALUES (值1, 值2, ...); 批量添加数据：INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); 注意事项 字符串和日期类型数据应该包含在引号中 插入的数据大小应该在字段的规定范围内 更新和删除数据修改数据：UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];例：UPDATE emp SET name = 'Jack' WHERE id = 1; 删除数据：DELETE FROM 表名 [ WHERE 条件 ]; DQL（数据查询语言）语法： SELECT 字段列表 FROM 表名字段 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后的条件列表 ORDER BY 排序字段列表 LIMIT 分页参数 基础查询查询多个字段：SELECT 字段1, 字段2, 字段3, ... FROM 表名;SELECT * FROM 表名; 设置别名：SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名; 去除重复记录：SELECT DISTINCT 字段列表 FROM 表名; 转义：SELECT * FROM 表名 WHERE name LIKE '/_张三' ESCAPE '/'/ 之后的_不作为通配符 条件查询语法：SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件： 比较运算符 功能 &gt; 大于 &gt;= 大于等于 &lt; 小于 &lt;= 小于等于 = 等于 &lt;&gt; 或 != 不等于 BETWEEN … AND … 在某个范围内（含最小、最大值） IN(…) 在in之后的列表中的值，多选一 LIKE 占位符 模糊匹配（_匹配单个字符，%匹配任意个字符） IS NULL 是NULL 逻辑运算符 功能 AND 或 &amp;&amp; 并且（多个条件同时成立） OR 或 || 或者（多个条件任意一个成立） NOT 或 ! 非，不是 例子： -- 年龄等于30 select * from employee where age = 30; -- 年龄小于30 select * from employee where age &lt; 30; -- 小于等于 select * from employee where age &lt;= 30; -- 没有身份证 select * from employee where idcard is null or idcard = ''; -- 有身份证 select * from employee where idcard; select * from employee where idcard is not null; -- 不等于 select * from employee where age != 30; -- 年龄在20到30之间 select * from employee where age between 20 and 30; select * from employee where age &gt;= 20 and age &lt;= 30; -- 下面语句不报错，但查不到任何信息 select * from employee where age between 30 and 20; -- 性别为女且年龄小于30 select * from employee where age &lt; 30 and gender = '女'; -- 年龄等于25或30或35 select * from employee where age = 25 or age = 30 or age = 35; select * from employee where age in (25, 30, 35); -- 姓名为两个字 select * from employee where name like '__'; -- 身份证最后为X select * from employee where idcard like '%X'; 聚合查询（聚合函数）常见聚合函数： 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 语法：SELECT 聚合函数(字段列表) FROM 表名;例：SELECT count(id) from employee where workaddress = \"广东省\"; 分组查询语法：SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ]; where 和 having 的区别： 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。 例子： -- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女） select count(*) from employee group by gender; -- 根据性别分组，统计男性和女性数量 select gender, count(*) from employee group by gender; -- 根据性别分组，统计男性和女性的平均年龄 select gender, avg(age) from employee group by gender; -- 年龄小于45，并根据工作地址分组 select workaddress, count(*) from employee where age &lt; 45 group by workaddress; -- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址 select workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;= 3; 注意事项 执行顺序：where &gt; 聚合函数 &gt; having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 排序查询语法：SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2; 排序方式： ASC: 升序（默认） DESC: 降序 例子： -- 根据年龄升序排序 SELECT * FROM employee ORDER BY age ASC; SELECT * FROM employee ORDER BY age; -- 两字段排序，根据年龄升序排序，入职时间降序排序 SELECT * FROM employee ORDER BY age ASC, entrydate DESC; 注意事项如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 分页查询语法：SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数; 例子： -- 查询第一页数据，展示10条 SELECT * FROM employee LIMIT 0, 10; -- 查询第二页 SELECT * FROM employee LIMIT 10, 10; 注意事项 起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10 DQL执行顺序FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT DCL管理用户查询用户： USE mysql; SELECT * FROM user; 创建用户:CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 修改用户密码：ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码'; 删除用户：DROP USER '用户名'@'主机名'; 例子： -- 创建用户test，只能在当前主机localhost访问 create user 'test'@'localhost' identified by '123456'; -- 创建用户test，能在任意主机访问 create user 'test'@'%' identified by '123456'; create user 'test' identified by '123456'; -- 修改密码 alter user 'test'@'localhost' identified with mysql_native_password by '1234'; -- 删除用户 drop user 'test'@'localhost'; 注意事项 主机名可以使用 % 通配 权限控制常用权限： 权限 说明 ALL, ALL PRIVILEGES 所有权限 SELECT 查询数据 INSERT 插入数据 UPDATE 修改数据 DELETE 删除数据 ALTER 修改表 DROP 删除数据库/表/视图 CREATE 创建数据库/表 更多权限请看权限一览表 查询权限：SHOW GRANTS FOR '用户名'@'主机名'; 授予权限：GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名'; 撤销权限：REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名'; 注意事项 多个权限用逗号分隔 授权时，数据库名和表名可以用 * 进行通配，代表所有 函数 字符串函数 数值函数 日期函数 流程函数 字符串函数常用函数： 函数 功能 CONCAT(s1, s2, …, sn) 字符串拼接，将s1, s2, …, sn拼接成一个字符串 LOWER(str) 将字符串全部转为小写 UPPER(str) 将字符串全部转为大写 LPAD(str, n, pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 RPAD(str, n, pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 TRIM(str) 去掉字符串头部和尾部的空格 SUBSTRING(str, start, len) 返回从字符串str从start位置起的len个长度的字符串 REPLACE(column, source, replace) 替换字符串 使用示例： -- 拼接 SELECT CONCAT('Hello', 'World'); -- 小写 SELECT LOWER('Hello'); -- 大写 SELECT UPPER('Hello'); -- 左填充 SELECT LPAD('01', 5, '-'); -- 右填充 SELECT RPAD('01', 5, '-'); -- 去除空格 SELECT TRIM(' Hello World '); -- 切片（起始索引为1） SELECT SUBSTRING('Hello World', 1, 5); 数值函数常见函数： 函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x, y) 返回x/y的模 RAND() 返回0~1内的随机数 ROUND(x, y) 求参数x的四舍五入值，保留y位小数 日期函数常用函数： 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前日期和时间 YEAR(date) 获取指定date的年份 MONTH(date) 获取指定date的月份 DAY(date) 获取指定date的日期 DATE_ADD(date, INTERVAL expr type) 返回一个日期/时间值加上一个时间间隔expr后的时间值 DATEDIFF(date1, date2) 返回起始时间date1和结束时间date2之间的天数 例子： -- DATE_ADD SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR); 流程函数常用函数： 函数 功能 IF(value, t, f) 如果value为true，则返回t，否则返回f IFNULL(value1, value2) 如果value1不为空，返回value1，否则返回value2 CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果val1为true，返回res1，… 否则返回default默认值 CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果expr的值等于val1，返回res1，… 否则返回default默认值 例子： select name, (case when age &gt; 30 then '中年' else '青年' end) from employee; select name, (case workaddress when '北京市' then '一线城市' when '上海市' then '一线城市' else '二线城市' end) as '工作地址' from employee; 约束分类： 约束 描述 关键字 非空约束 限制该字段的数据不能为null NOT NULL 唯一约束 保证该字段的所有数据都是唯一、不重复的 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且唯一 PRIMARY KEY 默认约束 保存数据时，如果未指定该字段的值，则采用默认值 DEFAULT 检查约束（8.0.1版本后） 保证字段值满足某一个条件 CHECK 外键约束 用来让两张图的数据之间建立连接，保证数据的一致性和完整性 FOREIGN KEY 约束是作用于表中字段上的，可以再创建表/修改表的时候添加约束。 常用约束 约束条件 关键字 主键 PRIMARY KEY 自动增长 AUTO_INCREMENT 不为空 NOT NULL 唯一 UNIQUE 逻辑条件 CHECK 默认值 DEFAULT 例子： create table user( id int primary key auto_increment, name varchar(10) not null unique, age int check(age &gt; 0 and age &lt; 120), status char(1) default '1', gender char(1) ); 外键约束添加外键： CREATE TABLE 表名( 字段名 字段类型, ... [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名) ); ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名); -- 例子 alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id); 删除外键：ALTER TABLE 表名 DROP FOREIGN KEY 外键名; 删除/更新行为 行为 说明 NO ACTION 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致） RESTRICT 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致） CASCADE 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录 SET NULL 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null） SET DEFAULT 父表有变更时，子表将外键设为一个默认值（Innodb不支持） 更改删除/更新行为：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为; 多表查询多表关系 一对多（多对一） 多对多 一对一 一对多案例：部门与员工关系：一个部门对应多个员工，一个员工对应一个部门实现：在多的一方建立外键，指向一的一方的主键 多对多案例：学生与课程关系：一个学生可以选多门课程，一门课程也可以供多个学生选修实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键 一对一案例：用户与用户详情关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE） 查询合并查询（笛卡尔积，会展示所有组合结果）：select * from employee, dept; 笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积） 消除无效笛卡尔积：select * from employee, dept where employee.dept = dept.id; 内连接查询内连接查询的是两张表交集的部分 隐式内连接：SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...; 显式内连接：SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...; 显式性能比隐式高 例子： -- 查询员工姓名，及关联的部门的名称 -- 隐式 select e.name, d.name from employee as e, dept as d where e.dept = d.id; -- 显式 select e.name, d.name from employee as e inner join dept as d on e.dept = d.id; 外连接查询左外连接：查询左表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;相当于查询表1的所有数据，包含表1和表2交集部分数据 右外连接：查询右表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...; 例子： -- 左 select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id; select d.name, e.* from dept d left outer join emp e on e.dept = d.id; -- 这条语句与下面的语句效果一样 -- 右 select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id; 左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept 自连接查询当前表与自身的连接查询，自连接必须使用表别名 语法：SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...; 自连接查询，可以是内连接查询，也可以是外连接查询 例子： -- 查询员工及其所属领导的名字 select a.name, b.name from employee a, employee b where a.manager = b.id; -- 没有领导的也查询出来 select a.name, b.name from employee a left join employee b on a.manager = b.id; 联合查询 union, union all把多次查询的结果合并，形成一个新的查询集 语法： SELECT 字段列表 FROM 表A ... UNION [ALL] SELECT 字段列表 FROM 表B ... 注意事项 UNION ALL 会有重复结果，UNION 不会 联合查询比使用or效率高，不会使索引失效 子查询SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个 根据子查询结果可以分为： 标量子查询（子查询结果为单个值） 列子查询（子查询结果为一列） 行子查询（子查询结果为一行） 表子查询（子查询结果为多行多列） 根据子查询位置可分为： WHERE 之后 FROM 之后 SELECT 之后 标量子查询子查询返回的结果是单个值（数字、字符串、日期等）。常用操作符：- &lt; &gt; &gt; &gt;= &lt; &lt;= 例子： -- 查询销售部所有员工 select id from dept where name = '销售部'; -- 根据销售部部门ID，查询员工信息 select * from employee where dept = 4; -- 合并（子查询） select * from employee where dept = (select id from dept where name = '销售部'); -- 查询xxx入职之后的员工信息 select * from employee where entrydate &gt; (select entrydate from employee where name = 'xxx'); 列子查询返回的结果是一列（可以是多行）。 常用操作符： 操作符 描述 IN 在指定的集合范围内，多选一 NOT IN 不在指定的集合范围内 ANY 子查询返回列表中，有任意一个满足即可 SOME 与ANY等同，使用SOME的地方都可以使用ANY ALL 子查询返回列表的所有值都必须满足 例子： -- 查询销售部和市场部的所有员工信息 select * from employee where dept in (select id from dept where name = '销售部' or name = '市场部'); -- 查询比财务部所有人工资都高的员工信息 select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = '财务部')); -- 查询比研发部任意一人工资高的员工信息 select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = '研发部')); 行子查询返回的结果是一行（可以是多列）。常用操作符：=, &lt;, &gt;, IN, NOT IN 例子： -- 查询与xxx的薪资及直属领导相同的员工信息 select * from employee where (salary, manager) = (12500, 1); select * from employee where (salary, manager) = (select salary, manager from employee where name = 'xxx'); 表子查询返回的结果是多行多列常用操作符：IN 例子： -- 查询与xxx1，xxx2的职位和薪资相同的员工 select * from employee where (job, salary) in (select job, salary from employee where name = 'xxx1' or name = 'xxx2'); -- 查询入职日期是2006-01-01之后的员工，及其部门信息 select e.*, d.* from (select * from employee where entrydate &gt; '2006-01-01') as e left join dept as d on e.dept = d.id; 事务事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 基本操作-- 1. 查询张三账户余额 select * from account where name = '张三'; -- 2. 将张三账户余额-1000 update account set money = money - 1000 where name = '张三'; -- 此语句出错后张三钱减少但是李四钱没有增加 模拟sql语句错误 -- 3. 将李四账户余额+1000 update account set money = money + 1000 where name = '李四'; -- 查看事务提交方式 SELECT @@AUTOCOMMIT; -- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效 SET @@AUTOCOMMIT = 0; -- 提交事务 COMMIT; -- 回滚事务 ROLLBACK; -- 设置手动提交后上面代码改为： select * from account where name = '张三'; update account set money = money - 1000 where name = '张三'; update account set money = money + 1000 where name = '李四'; commit; 操作方式二： 开启事务：START TRANSACTION 或 BEGIN TRANSACTION;提交事务：COMMIT;回滚事务：ROLLBACK; 操作实例： start transaction; select * from account where name = '张三'; update account set money = money - 1000 where name = '张三'; update account set money = money + 1000 where name = '李四'; commit; 四大特性ACID 原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败 一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态 隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行 持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的 并发事务问题 问题 描述 脏读 一个事务读到另一个事务还没提交的数据 不可重复读 一个事务先后读取同一条记录，但两次读取的数据不同 幻读 一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在 这三个问题的详细演示：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd 并发事务隔离级别： 隔离级别 脏读 不可重复读 幻读 Read uncommitted √ √ √ Read committed × √ √ Repeatable Read(默认) 可重复读 × × √ Serializable 串行化 × × × √表示在当前隔离级别下该问题会出现 Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差 查看事务隔离级别：SELECT @@TRANSACTION_ISOLATION;设置事务隔离级别：SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE };SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效 进阶篇存储引擎MySQL体系结构： 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。默认存储引擎是InnoDB。 相关操作： -- 查询建表语句 show create table account; -- 建表时指定存储引擎 CREATE TABLE 表名( ... ) ENGINE=INNODB; -- 查看当前数据库支持的存储引擎 show engines; InnoDBInnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。 特点： DML 操作遵循 ACID 模型，支持事务 行级锁，提高并发访问性能 支持外键约束，保证数据的完整性和正确性 文件： xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。 参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间 知识点： 查看 Mysql 变量：show variables like 'innodb_file_per_table'; 从idb文件提取表结构数据：（在cmd运行）ibd2sdi xxx.ibd InnoDB 逻辑存储结构： MyISAMMyISAM 是 MySQL 早期的默认存储引擎。 特点： 不支持事务，不支持外键 支持表锁，不支持行锁 访问速度快 文件： xxx.sdi: 存储表结构信息 xxx.MYD: 存储数据 xxx.MYI: 存储索引 MemoryMemory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。 特点： 存放在内存中，速度快 hash索引（默认） 文件： xxx.sdi: 存储表结构信息 存储引擎特点 特点 InnoDB MyISAM Memory 存储限制 64TB 有 有 事务安全 支持 - - 锁机制 行锁 表锁 表锁 B+tree索引 支持 支持 支持 Hash索引 - - 支持 全文索引 支持（5.6版本之后） 支持 - 空间使用 高 低 N/A 内存使用 高 低 中等 批量插入速度 低 高 高 支持外键 支持 - - 存储引擎的选择在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。 InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择 MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。 Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性 电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。 性能分析查看执行频次查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：SHOW GLOBAL STATUS LIKE 'Com_______'; 或者 SHOW SESSION STATUS LIKE 'Com_______';例：show global status like 'Com_______' 慢查询日志慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息： # 开启慢查询日志开关 slow_query_log=1 # 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志 long_query_time=2更改后记得重启MySQL服务，日志文件位置：/var/lib/mysql/localhost-slow.log 查看慢查询日志开关状态：show variables like 'slow_query_log'; profileshow profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：SELECT @@have_profiling;profiling 默认关闭，可以通过set语句在session/global级别开启 profiling：SET profiling = 1;查看所有语句的耗时：show profiles;查看指定query_id的SQL语句各个阶段的耗时：show profile for query query_id;查看指定query_id的SQL语句CPU的使用情况show profile cpu for query query_id; explainEXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。语法： # 直接在select语句之前加上关键字 explain / desc EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件; EXPLAIN 各字段含义： id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行） select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等 type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all possible_key：可能应用在这张表上的索引，一个或多个 Key：实际使用的索引，如果为 NULL，则没有使用索引 Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好 rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的 filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好 索引索引（index）是帮助 MySQL 高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。 优缺点： 优点： 提高数据检索效率，降低数据库的IO成本 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗 缺点： 索引列也是要占用空间的 索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE 索引结构 索引结构 描述 B+Tree 最常见的索引类型，大部分引擎都支持B+树索引 Hash 底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询 R-Tree(空间索引) 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 Full-Text(全文索引) 是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES 索引 InnoDB MyISAM Memory B+Tree索引 支持 支持 支持 Hash索引 不支持 不支持 支持 R-Tree索引 不支持 支持 不支持 Full-text 5.6版本后支持 支持 不支持 B-Tree 二叉树的缺点可以用红黑树来解决：红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。 为了解决上述问题，可以使用 B-Tree 结构。B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针） B-Tree 的数据插入过程动画参照：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68演示地址：https://www.cs.usfca.edu/~galles/visualization/BTree.html B+Tree结构图： 演示地址：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html 与 B-Tree 的区别： 所有的数据都会出现在叶子节点 叶子节点形成一个单向链表 MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。 ![MySQL B+Tree 结构图](https://dhc.pythonanywhere.com/media/editor/结构图_20220316171730865611.png\"MySQL B+Tree 结构图”) Hash哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。 特点： Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、&gt;、&lt;、…） 无法利用索引完成排序操作 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引 存储引擎支持： Memory InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的 面试题 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？ 相对于二叉树，层级更少，搜索效率高 对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低 相对于 Hash 索引，B+Tree 支持范围匹配及排序操作 索引分类 分类 含义 特点 关键字 主键索引 针对于表中主键创建的索引 默认自动创建，只能有一个 PRIMARY 唯一索引 避免同一个表中某数据列中的值重复 可以有多个 UNIQUE 常规索引 快速定位特定数据 可以有多个 全文索引 全文索引查找的是文本中的关键词，而不是比较索引中的值 可以有多个 FULLTEXT 在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种： 分类 含义 特点 聚集索引(Clustered Index) 将数据存储与索引放一块，索引结构的叶子节点保存了行数据 必须有，而且只有一个 二级索引(Secondary Index) 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 可以存在多个 演示图： 聚集索引选取规则： 如果存在主键，主键索引就是聚集索引 如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引 如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引 思考题1. 以下 SQL 语句，哪个执行效率高？为什么？ select * from user where id = 10; select * from user where name = 'Arm'; -- 备注：id为主键，name字段创建的有索引 答：第一条语句，因为第二条需要回表查询，相当于两个步骤。 2. InnoDB 主键索引的 B+Tree 高度为多少？ 答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.可得公式：n * 8 + (n + 1) * 6 = 16 * 1024，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。 如果树的高度为2，那么他能存储的数据量大概为：1171 * 16 = 18736；如果树的高度为3，那么他能存储的数据量大概为：1171 * 1171 * 16 = 21939856。 另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。 语法创建索引：CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引 查看索引：SHOW INDEX FROM table_name; 删除索引：DROP INDEX index_name ON table_name; 案例： -- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引 create index idx_user_name on tb_user(name); -- phone手机号字段的值非空，且唯一，为该字段创建唯一索引 create unique index idx_user_phone on tb_user (phone); -- 为profession, age, status创建联合索引 create index idx_user_pro_age_stat on tb_user(profession, age, status); -- 为email建立合适的索引来提升查询效率 create index idx_user_email on tb_user(email); -- 删除索引 drop index idx_user_email on tb_user; 使用规则最左前缀法则如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。 联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;=或者&lt;=来规避索引失效问题。 索引失效情况 在索引列上进行运算操作，索引将失效。如：explain select * from tb_user where substring(phone, 10, 2) = '15'; 字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone = 17799990015;，此处phone的值没有加引号 模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like '%工程';，前后都有 % 也会失效。 用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。 如果 MySQL 评估使用索引比全表更慢，则不使用索引。 SQL 提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。 例如，使用索引：explain select * from tb_user use index(idx_user_pro) where profession=\"软件工程\";不使用哪个索引：explain select * from tb_user ignore index(idx_user_pro) where profession=\"软件工程\";必须使用哪个索引：explain select * from tb_user force index(idx_user_pro) where profession=\"软件工程\"; use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。 覆盖索引&amp;回表查询尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。 explain 中 extra 字段含义：using index condition：查找使用了索引，但是需要回表查询数据using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询 如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name='xxx';，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name='xxx'; 所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段 面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：select id, username, password from tb_user where username='itcast'; 解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引 前缀索引当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。 语法：create index idx_xxxx on table_name(columnn(n));前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。求选择性公式： select count(distinct email) / count(*) from tb_user; select count(distinct substring(email, 1, 5)) / count(*) from tb_user; show index 里面的sub_part可以看到接取的长度 单列索引&amp;联合索引单列索引：即一个索引只包含单个列联合索引：即一个索引包含了多个列在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。 单列索引情况：explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信';这句只会用到phone索引字段 注意事项 多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询 设计原则 针对于数据量较大，且查询比较频繁的表建立索引 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高 如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询 SQL 优化插入数据普通插入： 采用批量插入（一次插入的数据不建议超过1000条） 手动提交事务 主键顺序插入 大批量插入：如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。 # 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入） mysql --local-infile -u root -p # 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关 set global local_infile = 1; select @@local_infile; # 执行load指令将准备好的数据，加载到表结构中 load data local infile '/root/sql1.log' into table 'tb_user' fields terminated by ',' lines terminated by '\\n'; 主键优化数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT） 页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。 MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定 文字说明不够清晰明了，具体可以看视频里的PPT演示过程：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90 主键设计原则： 满足业务需求的情况下，尽量降低主键的长度 插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键 尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号 业务操作时，避免对主键的修改 order by优化 Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序 Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高 如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是Using index, Using filesort，如果要优化掉Using filesort，则需要另外再创建一个索引，如：create index idx_user_age_phone_ad on tb_user(age asc, phone desc);，此时使用select id, age, phone from tb_user order by age asc, phone desc;会全部走索引 总结： 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则 尽量使用覆盖索引 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC） 如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k） group by优化 在分组操作时，可以通过索引来提高效率 分组操作时，索引的使用也是满足最左前缀法则的 如索引为idx_user_pro_age_stat，则句式可以是select ... where profession order by age，这样也符合最左前缀法则 limit优化常见的问题如limit 2000000, 10，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化 例如： -- 此语句耗时很长 select * from tb_sku limit 9000000, 10; -- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询 select id from tb_sku order by id limit 9000000, 10; -- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit -- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10); -- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度 select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id; count优化MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis count的几种用法： 如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值 用法：count(*)、count(主键)、count(字段)、count(1) count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0 各种用法的性能： count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空） count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加 count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加 count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加 按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*) update优化（避免行锁升级为表锁）InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。 如以下两条语句：update student set no = '123' where id = 1;，这句由于id有主键索引，所以只会锁这一行；update student set no = '123' where name = 'test';，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引 数据类型整型 类型名称 取值范围 大小 TINYINT -128〜127 1个字节 SMALLINT -32768〜32767 2个宇节 MEDIUMINT -8388608〜8388607 3个字节 INT (INTEGHR) -2147483648〜2147483647 4个字节 BIGINT -9223372036854775808〜9223372036854775807 8个字节 无符号在数据类型后加 unsigned 关键字。 浮点型 类型名称 说明 存储需求 FLOAT 单精度浮点数 4 个字节 DOUBLE 双精度浮点数 8 个字节 DECIMAL (M, D)，DEC 压缩的“严格”定点数 M+2 个字节 日期和时间 类型名称 日期格式 日期范围 存储需求 YEAR YYYY 1901 ~ 2155 1 个字节 TIME HH:MM:SS -838:59:59 ~ 838:59:59 3 个字节 DATE YYYY-MM-DD 1000-01-01 ~ 9999-12-3 3 个字节 DATETIME YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 8 个字节 TIMESTAMP YYYY-MM-DD HH:MM:SS 1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC 4 个字节 字符串 类型名称 说明 存储需求 CHAR(M) 固定长度非二进制字符串 M 字节，1&lt;=M&lt;=255 VARCHAR(M) 变长非二进制字符串 L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255 TINYTEXT 非常小的非二进制字符串 L+1字节，在此，L&lt;2^8 TEXT 小的非二进制字符串 L+2字节，在此，L&lt;2^16 MEDIUMTEXT 中等大小的非二进制字符串 L+3字节，在此，L&lt;2^24 LONGTEXT 大的非二进制字符串 L+4字节，在此，L&lt;2^32 ENUM 枚举类型，只能有一个枚举字符串值 1或2个字节，取决于枚举值的数目 (最大值为65535) SET 一个设置，字符串对象可以有零个或 多个SET成员 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） 二进制类型 类型名称 说明 存储需求 BIT(M) 位字段类型 大约 (M+7)/8 字节 BINARY(M) 固定长度二进制字符串 M 字节 VARBINARY (M) 可变长度二进制字符串 M+1 字节 TINYBLOB (M) 非常小的BLOB L+1 字节，在此，L&lt;2^8 BLOB (M) 小 BLOB L+2 字节，在此，L&lt;2^16 MEDIUMBLOB (M) 中等大小的BLOB L+3 字节，在此，L&lt;2^24 LONGBLOB (M) 非常大的BLOB L+4 字节，在此，L&lt;2^32 权限一览表 具体权限的作用详见官方文档 GRANT 和 REVOKE 允许的静态权限 Privilege Grant Table Column Context ALL [PRIVILEGES] Synonym for “all privileges” Server administration ALTER Alter_priv Tables ALTER ROUTINE Alter_routine_priv Stored routines CREATE Create_priv Databases, tables, or indexes CREATE ROLE Create_role_priv Server administration CREATE ROUTINE Create_routine_priv Stored routines CREATE TABLESPACE Create_tablespace_priv Server administration CREATE TEMPORARY TABLES Create_tmp_table_priv Tables CREATE USER Create_user_priv Server administration CREATE VIEW Create_view_priv Views DELETE Delete_priv Tables DROP Drop_priv Databases, tables, or views DROP ROLE Drop_role_priv Server administration EVENT Event_priv Databases EXECUTE Execute_priv Stored routines FILE File_priv File access on server host GRANT OPTION Grant_priv Databases, tables, or stored routines INDEX Index_priv Tables INSERT Insert_priv Tables or columns LOCK TABLES Lock_tables_priv Databases PROCESS Process_priv Server administration PROXY See proxies_priv table Server administration REFERENCES References_priv Databases or tables RELOAD Reload_priv Server administration REPLICATION CLIENT Repl_client_priv Server administration REPLICATION SLAVE Repl_slave_priv Server administration SELECT Select_priv Tables or columns SHOW DATABASES Show_db_priv Server administration SHOW VIEW Show_view_priv Views SHUTDOWN Shutdown_priv Server administration SUPER Super_priv Server administration TRIGGER Trigger_priv Tables UPDATE Update_priv Tables or columns USAGE Synonym for “no privileges” Server administration GRANT 和 REVOKE 允许的动态权限 Privilege Context APPLICATION_PASSWORD_ADMIN Dual password administration AUDIT_ABORT_EXEMPT Allow queries blocked by audit log filter AUDIT_ADMIN Audit log administration AUTHENTICATION_POLICY_ADMIN Authentication administration BACKUP_ADMIN Backup administration BINLOG_ADMIN Backup and Replication administration BINLOG_ENCRYPTION_ADMIN Backup and Replication administration CLONE_ADMIN Clone administration CONNECTION_ADMIN Server administration ENCRYPTION_KEY_ADMIN Server administration FIREWALL_ADMIN Firewall administration FIREWALL_EXEMPT Firewall administration FIREWALL_USER Firewall administration FLUSH_OPTIMIZER_COSTS Server administration FLUSH_STATUS Server administration FLUSH_TABLES Server administration FLUSH_USER_RESOURCES Server administration GROUP_REPLICATION_ADMIN Replication administration GROUP_REPLICATION_STREAM Replication administration INNODB_REDO_LOG_ARCHIVE Redo log archiving administration NDB_STORED_USER NDB Cluster PASSWORDLESS_USER_ADMIN Authentication administration PERSIST_RO_VARIABLES_ADMIN Server administration REPLICATION_APPLIER PRIVILEGE_CHECKS_USER for a replication channel REPLICATION_SLAVE_ADMIN Replication administration RESOURCE_GROUP_ADMIN Resource group administration RESOURCE_GROUP_USER Resource group administration ROLE_ADMIN Server administration SESSION_VARIABLES_ADMIN Server administration SET_USER_ID Server administration SHOW_ROUTINE Server administration SYSTEM_USER Server administration SYSTEM_VARIABLES_ADMIN Server administration TABLE_ENCRYPTION_ADMIN Server administration VERSION_TOKEN_ADMIN Server administration XA_RECOVER_ADMIN Server administration 图形化界面工具 Workbench(免费): http://dev.mysql.com/downloads/workbench/ navicat(收费，试用版30天): https://www.navicat.com/en/download/navicat-for-mysql Sequel Pro(开源免费，仅支持Mac OS): http://www.sequelpro.com/ HeidiSQL(免费): http://www.heidisql.com/ phpMyAdmin(免费): https://www.phpmyadmin.net/ SQLyog: https://sqlyog.en.softonic.com/ 安装小技巧 在SQL语句之后加上\\G会将结果的表格形式转换成行文本形式 查看Mysql数据库占用空间： SELECT table_schema \"Database Name\" , SUM(data_length + index_length) / (1024 * 1024) \"Database Size in MB\" FROM information_schema.TABLES GROUP BY table_schema;","categories":[{"name":"学习笔记集","slug":"学习笔记集","permalink":"https://2825958739.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9B%86/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://2825958739.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL","slug":"SQL","permalink":"https://2825958739.github.io/tags/SQL/"}],"author":"chenliang"},{"title":"PicGo上传图片成功，但是GitHub图床上图片不显示问题","slug":"PicGo-error","date":"2023-03-02T09:59:18.000Z","updated":"2023-03-02T10:28:51.992Z","comments":true,"path":"posts/77c754e.html","link":"","permalink":"https://2825958739.github.io/posts/77c754e.html","excerpt":"","text":"​ 前两天用 PicGo+github 做了个图床，在 PicGo 上把 github 的相关配置弄好后，成功实现了图片上传，而且访问图片链接也能成功显示出图片，但是今天打开博客文章发现文章中的图片迟迟加载不出来，刚开始我还以为是 github 访问慢造成的，后面又刷新了几次还是没加载，所以我就感觉出问题了。 错误：在 github 的图床中打开图片报错Failed to load resource: net::ERR_NAME_NOT_RESOLVE 原因与解决方法：官方更新了 dns，但是 dns 缓存没有被更新，导致错误解析。 打开一个域名解析网站 ping.eu/nslookup 获取图片域名（raw.githubusercontent.com）的真实 ip 地址： 把以上 IP 和域名映射起来：先找到 C:\\Windows\\System32\\drivers\\etc\\hosts 文件，使用文本编辑器打开。再在文件后面添加以下内容 185.199.108.133 raw.githubusercontent.com 然后保存就可以了，如果遇到图片又不能显示了，大家可依据上述方法及时更新 ip 配置 host 文件即可。","categories":[{"name":"错误集","slug":"错误集","permalink":"https://2825958739.github.io/categories/%E9%94%99%E8%AF%AF%E9%9B%86/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"https://2825958739.github.io/tags/PicGo/"},{"name":"图床","slug":"图床","permalink":"https://2825958739.github.io/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"域名解析","slug":"域名解析","permalink":"https://2825958739.github.io/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"}],"author":"chenliang"},{"title":"智能环保小灯","slug":"Intelligent-environmental-protection-lamp","date":"2023-03-02T08:02:09.000Z","updated":"2023-03-02T10:28:51.985Z","comments":true,"path":"posts/e515d166.html","link":"","permalink":"https://2825958739.github.io/posts/e515d166.html","excerpt":"","text":"项目背景随着物联网技术的不断发展，传统的普通家居形式已经无法满足现今的万物互联及智能化的需求，家居设计者迫切需要更具现代化、更加智能的家居新模式。智能家居的出现，在实现家居正常功能的前提下，增加了许多新特性，极大地满足了居住者的需求。 信息技术的飞速发展，人类活动产生的数据量空前地增长，各类设备对数据的处理速度也在迅速地提升，大数据时代已经到来。大数据技术促进了很多行业的技术革新，人们的家居方式也依托数据处理不断地朝着数据化、网络化的方向发展。除了传统家居的一些基本功能之外，智能家居能够让人们对家中物品的使用情况了解得更加详细，同时也能更方便地远程控制家居物品。 需求分析在我们的日常生活中，很多人没有随手关灯的习惯，比如在寝室有的人懒的可怕，从而产生了些没必要的电资源浪费。为解决许多人没有随手关灯的好习惯而导致的电资源浪费的问题，有数据显示，光是每天下班后不关闭电源将导致全国每年将浪费电12.775亿千瓦时。所以节能将耗是刻不容缓的事情，而我设计的这款智能环保小灯能有效解决这个问题，实现真正的人走灯灭，无线控制。这款小夜灯有如下功能： 智能环保小灯配备人体红外感应传感器以及光敏电阻实现照明的自动化，点亮和熄灭时会产生渐明渐暗效果，在点亮过程中有呼吸灯的效果。 接入点灯科技物联网应用平台，可通过手机APP检测各项数据并控制小灯的开和关。该多功能智能电灯拥有一个系统默认颜色，若用户想显示其他颜色可通过手机APP进行上的滑条进行设置，从而实现一个氛围灯的效果。 于此同时还接入了小爱同学，实现照明的智能化，可通过语音指令控制多功能智能电灯的开关及亮度调节。让懒人躺在床上闭着眼也能关上灯。 通过ESP8266实现设备的联网，设备在线时，每隔一分钟就会自动的反馈设备状况。 硬件选择与设计材料准备 环保智能小夜灯制作材料清单： 名称 数量 价格/元 NodemcuESP8266开发板 1 13 红外人体感应模块 1 4.16 光敏电阻（5528） 1 0.2 分压电阻 (10KΩ – 配合5528光敏电阻用) 1 RGB LED（共阴极） 1 限流电阻 100Ω 3 面包板 1 杜邦线 20 USB 延长线 1 NodeMCU开发板ESP8266-NodeMCU是一个开源硬件开发板，由于它支持WIFI功能，所以在物联网（IOT）领域，Arduino开发板最大的对手之一就是ESP8266-NodeMCU开发板。ESP8266-NodeMCU尺寸与Nano类似, 他并不是Arduino团队开发的，但是我们也可以使用Arduino IDE 对他进行开发。而且他还有一颗地道的“中国芯”—ESP8266模块。 NodeMCU开发板上的两排插针与ESP8266芯片的引脚相连。有了开发板上的两排插针，我们就可以很轻松的使用杜邦线将芯片的引脚接到实验电路中。NodeMCU开发板上还配有USB接口以及电压转换电路。这些为我们提供了很大的便利。我们只要用一根USB数据线就可以轻松的实现为ESP8266供电以及上传程序的操作。 电压电流限制： NodeMCU开发板引脚的输入输出电压限制是3.3 V。如果向引脚施加3.6V以上的电压就有可能对芯片电路造成损坏。同时请注意，这些引脚的最大输出电流是12mA。由于NodeMCU开发板的引脚允许电压和电流都是低于Arduino开发板的引脚，所以如您想要将NodeMCU与Arduino引脚相互连接，请特别注意这两个开发板的引脚电压和电流的区别。如果操作不当可能会损坏NodeMCU开发板。 特殊引脚情况说明： GPIO2引脚 在NodeMCU开发板启动时是不能连接低电平的。 GPIO15引脚在开发板运行中一直保持低电平状态。因此请不要使用GPIO15引脚来读取开关状态或进行I²C通讯。 GPIO0引脚在开发板运行中需要一直保持高电平状态。否则ESP8266将进入程序上传工作模式也就无法正常工作了。您无需对GPIO0引脚进行额外操作，因为NodeMCU的内置电路可以确保GPIO0引脚在工作时连接高电平而在上传程序时连接低电平。 上拉电阻/下拉电阻 GPIO 0-15引脚都配有内置上拉电阻。这一点与Arduino十分类似。GPIO16 引脚配有内置下拉电阻。 模拟输入 ESP8266 只有一个模拟输入引脚（该引脚通过模拟-数字转换将引脚上的模拟电压数值转化为数字量）。此引脚可以读取的模拟电压值为 0 – 1.0V。请注意：ESP8266 芯片模拟输入引脚连接在1.0V以上电压可能损坏ESP8266芯片。 以上所描述的是针对ESP8266芯片的引脚。而对于NodeMCU开发板引脚，情况就不同了。 NodeMCU开发板配有降压电路。您可以用NodeMCU开发板的模拟输入引脚读取0-3.3V的模拟电压信号。 通讯串行端口 ESP8266有2个硬件串行端口（UART）。 串行端口0（UART0）使用GPIO1和GPIO3引脚。其中GPIO1引脚是TX0，GPIO3是RX0。 串行端口1（UART1）使用GPIO2和GPIO8引脚。其中GPIO2引脚是TX1，GPIO8是RX1。请注意，由于GPIO8被用于连接闪存芯片，串行端口1只能使用GPIO2来向外发送串行数据。 I²C：ESP8266只有软件模拟的I²C端口，没有硬件I²C端口。也就是说我们可以使用任意的两个GPIO引脚通过软件模拟来实现I²C通讯。ESP8266的数据表（datasheet）中，GPIO2标注为SDA，GPIO14标注为SCL。 SPI：ESP8266的SPI端口情况如下：GPIO14 — CLK、GPIO12 — MISO、GPIO13 — MOSI、GPIO 15 — CS(SS) ESP8266芯片： ESP8266-NodeMCU引脚： 人体红外感应传感器模块红外热释电传感器是一款基于热释电效应的人体热释运动传感器，能检测到人体或动物身上发出的红外线，配合菲涅尔透镜能使传感器探测范围更远更广。可在控制器上编程应用，通过3P传感器连接线插接到专用传感器扩展板上使用，可以轻松实现人体或动物检测的相关的互动效果。 基于红外线技术的自动控制产品，当有人进入开关感应范围时，专用传感器探测到人体红外光谱的变化，自动输出高电平，人不离开感应范围，将持续输出高电平；人离开后，开关延时自动关闭负载。 工作原理 ​ 人体都有恒定的体温，一般在37度，所以会发出特定波长10UM左右的红外线，被动式红外探头就是靠探测人体发射的10UM左右的红外线而进行工作的。人体发射的10UM左右的红外线通过菲泥尔滤光片增强后聚集到红外感应源上。红外感应源通常采用热释电元件，这种元件在接收到人体红外辐射温度发生变化时就会失去电荷平衡，向外释放电荷，后续电路经检测处理后就能产生报警信号。 ​ 热释电效应：当一些晶体受热时，在晶体两端将会产生数量相等而符号相反的电荷。这种由于热变化而产生的电极化现象称为热释电效应。 菲涅耳透镜：根据菲涅耳原理制成，菲涅耳透镜分为折射式和反射式两种形式，其作用一是聚焦作用，将热释的红外信号折射（反射）在PIR上；二是将检测区内分为若干个明区和暗区，使进入检测区的移动物体能以温度变化的形式在PIR上产生变化热释红外信号，这样PIR就能产生变化电信号。使热释电人体红外传感器(PIR)灵敏度大大增加。 原理图计： 特性： 1、全自动感应:人进入其感应范围则输出高电平，人离开感应范围则自动延 时关闭高电平，输出低电平。 2、光敏控制（可选择，出厂时未设）可设置光敏控制，白天或光线强时不 感应。 3、温度补偿(可选择，出厂时未设)：在夏天当环境温度升高至 30～32℃， 探测距离稍变短，温度补偿可作一定的性能补偿。 4、两种触发方式：（可跳线选择） a、不可重复触发方式:即感应输出高电平后，延时时间段一结束，输出将自动从高电平变成低电平； b、可重复触发方式：即感应输出高电平后，在延时时间段内，如果有 人体在其感应范围活动，其输出将一直保持高电平，直到人离开后才延时将 高电平变为低电平（感应模块检测到人体的每一次活动后会自动顺延一个延 时时间段，并且以最后一次活动的时间为延时时间的起始点)。 5(默认设置:2.5S 封锁时间)：感应模块在每一次感应输出后（高电平变成 低电平），可以紧跟着设置一个封锁时间段，在此时间段内感应器不接受任何感 应信号。此功能可以实现“感应输出时间”和“封锁时间”两者的间隔工作，可应 用于间隔探测产品；同时此功能可有效抑制负载切换过程中产生的各种干扰。 (此 时间可设置在零点几秒 —几十秒钟)。 6、工作电压范围宽：默认工作电压 DC4.5V-20V。 7、微功耗:静态电流&lt;50 微安，特别适合干电池供电的自动控制产品。 8、输出高电平信号：可方便与各类电路实现对接。 光敏传感器模块为了降低成本，本案直接选用光敏电阻作为光照检测器件。 光敏电阻是一种感应光线的强弱的传感器。在光敏传感器中，当感应光强度不同，光敏探头内的电阻值就会有变化。光敏传感器适合测量室外自然光线，常用 于环境或生物监控中。光敏传感器内装有一个高精度的光电管，光电管内有一块由 “针式二管”组成的小平板，当向光电管两端施加一个反向的固定压时，任何光了 对它的冲击都将导致其释放出电子，结果是，当光照强度越高，光电管的电流也就越 大，电流通过一个电阻时，电阻两端的电压被转换成可被采集器的数模转换器接受的 0-5V 电压，然后采集以适当的形式把结果保存下来.简单的说，光敏传感器就是利用光敏电阻受光线强度影响而阻值发生变化的原理向机器人主机发送光线强度的模拟信号。 原理图设计： 特性： 1、光敏电阻模块对环境光线最敏感，一般用来检测周围环境的光线的亮度，触发单片机或继电器模块等； 2、体积小、反应速度快、安全性能高、寿命长 3、性能稳定、绿色环保 线路搭建 软件设计搭建Arduino IDE开发环境安装 ESP8266-NodeMCU开发板驱动 NodeMCU开发板不是即插即用的设备，因此我们先要为它在电脑上安装驱动程序以后才能使用。准备安装驱动程序安装 ESP8266-NodeMCU开发板驱动前，请先确保您的电脑已连接互联网。另外，请将NodeMCU开发板和USB数据线准备好以备安装使用。 为ESP8266-NodeMCU搭建Arduino IDE开发环境 NodeMCU开发板的无线终端模式 点灯科技物联网平台物联网应用平台的选择：点灯科技 简介：点灯是一套专业且易用物联网解决方案，提供了服务器、应用、设备端sdk支持。 基于高性能异步框架开发的服务器端可以承载大量设备连接，让设备所有者方便的进行设备管理；简单便捷的应用配合多设备支持的sdk，可以让开发者在3分钟内实现设备的接入。 点灯服务有三个版本，社区版开源且免费，让大家可以体验到点灯方案的特点和优势；云服务版提供更多增值服务与功能，且有效降低客户的项目实施成本，让客户更快的进行物联网升级；商业版可进行独立部署，可以满足客户更多样的需求； 物联网应用平台的使用： 1、**下载安装blinker-Arduino的库：**打开arduino，点击项目，——加载库——管理库下搜索blinker安装最新版本 2、下载BlinkerAPP**按照图片上的步骤可以获取到secret Key** 。 3、**手机上的小爱配置** 对小爱说：“打开灯”、“关闭灯”、“将灯的亮度调为50” 4、用手机给esp8266配网： 项目代码","categories":[{"name":"物联网应用集","slug":"物联网应用集","permalink":"https://2825958739.github.io/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E9%9B%86/"}],"tags":[{"name":"物联网应用","slug":"物联网应用","permalink":"https://2825958739.github.io/tags/%E7%89%A9%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8/"},{"name":"智能小灯","slug":"智能小灯","permalink":"https://2825958739.github.io/tags/%E6%99%BA%E8%83%BD%E5%B0%8F%E7%81%AF/"},{"name":"语音控制","slug":"语音控制","permalink":"https://2825958739.github.io/tags/%E8%AF%AD%E9%9F%B3%E6%8E%A7%E5%88%B6/"},{"name":"App控制","slug":"App控制","permalink":"https://2825958739.github.io/tags/App%E6%8E%A7%E5%88%B6/"}],"author":"chenliang"},{"title":"npm运行项目时出错及解决方法","slug":"npm_wrong","date":"2023-02-28T11:09:33.000Z","updated":"2023-02-28T11:13:30.062Z","comments":true,"path":"posts/d15571c7.html","link":"","permalink":"https://2825958739.github.io/posts/d15571c7.html","excerpt":"","text":"1、npm install报错 2、npm run serve 报错 原因与解决方案：电脑安装的node版本过高，安装低版本16.最好不使用17及以上版本，再次npm run serve即可 3、编译时出现下面错误 原因与解决方案：这次的错误原因是系统的环境变量没有配置好，刚开始看网上说的还以为是端口被占用了，但是释放端口后还是报错。应该要在环境变量Path中添加C:\\Windows\\System32或%SystemRoot%\\system32; 具体步骤：右键我的电脑–高级系统设置–高级–环境变量–系统变量，找到Path，点击添加 注意：设置完要重新启动vscode才可以生效哦！！ 4、npm run dev 报错 原因与解决方案：8080端口被占用了，cmd输入netstat -ano找到 8080端口所在的 PID ，然后打开“任务管理器”找到PID，终止程序即可。 5、node权限错误Error: EPERM: operation not permitted, mkdir ‘E:\\noddejs\\node_modules\\hexo-cli’] 原因与解决方案：没有权限操作nodejs的安装目录。 在nodejs 的安装目录右击 选择 属性 &gt; tab栏点击 安全 &gt; 编辑按钮 &gt; 下边的权限至少选择到修改 &gt; 可以选择完全控制。然后再次运行安装命令即可。","categories":[{"name":"错误集","slug":"错误集","permalink":"https://2825958739.github.io/categories/%E9%94%99%E8%AF%AF%E9%9B%86/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://2825958739.github.io/tags/npm/"}],"author":"chenliang"},{"title":"koa2框架中使用nodemon热更新","slug":"nodemon","date":"2023-02-27T13:03:56.000Z","updated":"2023-02-28T04:14:00.466Z","comments":true,"path":"posts/e69338fc.html","link":"","permalink":"https://2825958739.github.io/posts/e69338fc.html","excerpt":"","text":"1、首先要在vscode终端使用如下命令安装nodemon npm install nodemon –save 2、在项目package.json文件中配置启动命令本来的命令是 start:node bin/www改为start:nodemon bin/www即可 使用npm start启动项目，启动成功，以后再修改代码时项目就会自动更新加载了。","categories":[{"name":"工具篇","slug":"工具篇","permalink":"https://2825958739.github.io/categories/%E5%B7%A5%E5%85%B7%E7%AF%87/"}],"tags":[{"name":"nodemon","slug":"nodemon","permalink":"https://2825958739.github.io/tags/nodemon/"},{"name":"koa2","slug":"koa2","permalink":"https://2825958739.github.io/tags/koa2/"}]},{"title":"PicGo+GitHub 图床搭建","slug":"PicGo-GitHub","date":"2023-02-04T16:00:00.000Z","updated":"2023-02-28T04:13:32.265Z","comments":true,"path":"posts/7a46f93c.html","link":"","permalink":"https://2825958739.github.io/posts/7a46f93c.html","excerpt":"","text":"前言用GitHub搭建图床，在很久之前我就有了解，但由于市面上有挺多免费的图床，比如我之前一直在用的 路过图床，所以一直懒得动手搭建GitHub图床。一直到前两天我在完善博客的相册时，发现 路过图床 免费版的有这么多限制，比如：每小时限制上传50张图片，每天限制上传100张图片，而且免费版用户的存储容量貌似不过300M，这才意识到有一个自己的GitHub图床是多么重要。 0x001 PicGO 介绍PicGo是一款图片上传工具，目前支持 SM.MS图床、腾讯云COS、GitHub图床、七牛图床、Imgur图床、阿里云OSS、又拍云图床，未来将支持更多图床。 在支持的这些图床中，SM.MS和Imgur有免费版和收费版，免费版的肯定有很多的使用限制，比如每小时限制上传次数，限制用户的上传容量等等；腾讯云COS、阿里云、有拍云都是要收费使用的；七牛云貌似前期使用免费，后期又要收费才能使用，就剩下的GitHub才是免费且最可靠的。 PicGo源项目GitHub地址已给出，但是去GitHub下载速度非常慢，这里额外提供一个蓝奏云的快速下载地址。 GitHub地址：https://github.com/Molunerfinn/PicGo 0x002 GitHub 图床1. 创建GitHub图床仓库首先需要有一个登录GitHub的账号，没有的话去GitHub官网注册一个 创建一个新的图床仓库，点击右上角的New repository 填写如下配置信息，然后Create创建仓库 2. 获取GitHub token值点击右上的头像，选择设置Setting 点击选择Developer settings 点击 Generate New token 填写如下配置信息，只要勾选repo选项即可，然后页面拉到底部点击Generate token 即可 此时会跳转到带有token的页面，将token值复制记录下来，之后用PicGo绑定GitHub图床时会利用到 0x003 PicGo 配置1. 绑定GitHub图床首先下载安装好PicGo软件，然后在右列表找到GitHub图床配置 1. 设定仓库名(必填)： 按照“GitHub账户名/仓库名的格式填写”，比如我的是：Luckyzmj/imgbed 2. 设定分支名(必填)： 仓库分支名填写”master”或者”main”，视情况而定。因为GitHub 官方表示,从2020年10月1日起,在该平台上创建的所有新的源代码仓库将默认被命名为”main”,而不是原先的”master”。 3. 设定Token(必填)： 将之前步骤的Token值复制粘贴到这里 4. 指定存储路径： 这个选项可以为空，如果想将图片上传到仓库的指定目录下，可以填写目录名加/，比如我的imgbed仓库下有个posts文件夹，需设置为 posts/ 5. 设定自定义域名： 这里统一用jsdelivr的CDN加速域名，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接 自定义域名格式：https://cdn.jsdelivr.net/gh/GitHub账户名/仓库名 以我的格式为例：https://cdn.jsdelivr.net/gh/Luckyzmj/imgbed 配置完全部信息后，点击 设为默认图床，最后点击确定即可 2. 上传图片到图床在上传区上传图片，可支持本地图片上传(可多选图片)、剪贴板上传、URL上传等三种方式。上传图片成功后，选择你想要生成的图片链接格式 在图片区，可以看到成功上传的图片，选择相应的图片进行操作即可 3. PicGo 注意事项如果配置完PicGo后却上传图片失败，可以参考以下方法： 检查自定义域名是否正确 仓库名不要有空格 图片名字不要带有特殊符号，如：%、+、*、空格等 建议开启时间戳重命名，防止图片名字重复 上传图片间歇太短，需在PicGo设置中关闭Server选项 PicGo应用不稳定因素，需重启应用 参考文章 https://blog.csdn.net/sunhwee/article/details/100109956","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://2825958739.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"https://2825958739.github.io/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"https://2825958739.github.io/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"chenliang"}],"categories":[{"name":"面试题","slug":"面试题","permalink":"https://2825958739.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"物联网应用集","slug":"物联网应用集","permalink":"https://2825958739.github.io/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E9%9B%86/"},{"name":"学习笔记集","slug":"学习笔记集","permalink":"https://2825958739.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9B%86/"},{"name":"错误集","slug":"错误集","permalink":"https://2825958739.github.io/categories/%E9%94%99%E8%AF%AF%E9%9B%86/"},{"name":"工具篇","slug":"工具篇","permalink":"https://2825958739.github.io/categories/%E5%B7%A5%E5%85%B7%E7%AF%87/"},{"name":"博客篇","slug":"博客篇","permalink":"https://2825958739.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"tcp/ip网络协议","slug":"tcp-ip网络协议","permalink":"https://2825958739.github.io/tags/tcp-ip%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"HTTP","slug":"HTTP","permalink":"https://2825958739.github.io/tags/HTTP/"},{"name":"物联网系统","slug":"物联网系统","permalink":"https://2825958739.github.io/tags/%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F/"},{"name":"管道检测","slug":"管道检测","permalink":"https://2825958739.github.io/tags/%E7%AE%A1%E9%81%93%E6%A3%80%E6%B5%8B/"},{"name":"Esp8266-01s","slug":"Esp8266-01s","permalink":"https://2825958739.github.io/tags/Esp8266-01s/"},{"name":"水流量传感器","slug":"水流量传感器","permalink":"https://2825958739.github.io/tags/%E6%B0%B4%E6%B5%81%E9%87%8F%E4%BC%A0%E6%84%9F%E5%99%A8/"},{"name":"数据库","slug":"数据库","permalink":"https://2825958739.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL","slug":"SQL","permalink":"https://2825958739.github.io/tags/SQL/"},{"name":"PicGo","slug":"PicGo","permalink":"https://2825958739.github.io/tags/PicGo/"},{"name":"图床","slug":"图床","permalink":"https://2825958739.github.io/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"域名解析","slug":"域名解析","permalink":"https://2825958739.github.io/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"},{"name":"物联网应用","slug":"物联网应用","permalink":"https://2825958739.github.io/tags/%E7%89%A9%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8/"},{"name":"智能小灯","slug":"智能小灯","permalink":"https://2825958739.github.io/tags/%E6%99%BA%E8%83%BD%E5%B0%8F%E7%81%AF/"},{"name":"语音控制","slug":"语音控制","permalink":"https://2825958739.github.io/tags/%E8%AF%AD%E9%9F%B3%E6%8E%A7%E5%88%B6/"},{"name":"App控制","slug":"App控制","permalink":"https://2825958739.github.io/tags/App%E6%8E%A7%E5%88%B6/"},{"name":"npm","slug":"npm","permalink":"https://2825958739.github.io/tags/npm/"},{"name":"nodemon","slug":"nodemon","permalink":"https://2825958739.github.io/tags/nodemon/"},{"name":"koa2","slug":"koa2","permalink":"https://2825958739.github.io/tags/koa2/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"https://2825958739.github.io/tags/GitHub%E5%9B%BE%E5%BA%8A/"}]}